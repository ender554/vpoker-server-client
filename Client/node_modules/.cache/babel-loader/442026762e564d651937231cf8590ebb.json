{"ast":null,"code":"'use strict';\n/**\r\n * Randomization module\r\n *\r\n * @author     James Brumond\r\n * @version    1.0.0\r\n * @copyright  Copyright 2011/2016 James Brumond\r\n * @license    Dual licensed under MIT and GPL\r\n *\r\n * ------------------------------------------------------------------\r\n *\r\n * Methods:\r\n *   number    rand.double ([ string prng = 'SIMPLE' ])\r\n *   number    rand.int ([ object options { min, max, gen } ])\r\n *   number    rand.getGenerator ([ string prng = 'SIMPLE' ])\r\n *   number    rand.simple ( void )\r\n *   number    rand.arc4 ( void )\r\n *   string    rand.arc4.seed ([ string seed ])\r\n *   void      rand.shuffle ( array arr[, string prng = 'SIMPLE' ])\r\n */\n\n/* jshint esnext:true, globalstrict:true, node:true */\n\n/**\r\n * Wrapper for Math.random\r\n */\n\nexports.simple = function () {\n  return Math.random();\n};\n/**\r\n * Fetch a given PRNG function\r\n *\r\n * @access  public\r\n * @param   string    generator\r\n * @return  function\r\n */\n\n\nexports.getGenerator = function (gen) {\n  switch (gen || 'SIMPLE') {\n    case 'ARC4':\n      return exports.arc4;\n\n    case 'SIMPLE':\n      return exports.simple;\n\n    default:\n      throw 'Unknown value given for PRNG';\n  }\n};\n/**\r\n * Generate a random double using the given algorithm\r\n *\r\n * @access  public\r\n * @param   string    generator\r\n * @return  number\r\n */\n\n\nexports.double = function (gen) {\n  return exports.getGenerator(gen || 'SIMPLE')();\n};\n/**\r\n * Generate a random integer between min and max using the given generator\r\n *\r\n * @access  public\r\n * @param   object    options { min, max, gen }\r\n * @return  number\r\n */\n\n\nexports.int = function (opts) {\n  var ret;\n  opts.min = opts.min === void 0 ? 0 : opts.min;\n  opts.max = opts.max === void 0 ? 32000 : opts.max;\n\n  if (!opts.min && !opts.max) {\n    return 0;\n  }\n\n  ret = Math.floor(module.exports.double(opts.gen) * (opts.max + opts.min)) - opts.min;\n\n  if (ret === (opts.max || 1)) {\n    ret--;\n  }\n\n  return ret;\n}; // Returns a prng of a given type\n\n\nvar generator = function generator(gen) {\n  return function (max) {\n    return exports.int({\n      min: 0,\n      max: max,\n      gen: gen\n    });\n  };\n};\n/**\r\n * Shuffle an array in place using the fisher-yates algorithm\r\n *\r\n * @access  public\r\n * @param   array     the array to shuffle\r\n * @param   string    optionally, the PRNG to use\r\n * @return  void\r\n * @link    http://en.wikipedia.org/wiki/Fisher-Yates_shuffle\r\n */\n\n\nexports.shuffle = function (arr, prng) {\n  var randInt = generator(prng);\n\n  for (var i = arr.length - 1, j; i > 0; i--) {\n    var _j = randInt(i);\n\n    var tmp = arr[i];\n    arr[i] = arr[_j];\n    arr[_j] = tmp;\n  }\n};\n/**\r\n * ARC4 random double generator\r\n *\r\n * @function  number  module.exports.arc4 ( void )\r\n * @function  void    module.exports.arc4.seed ([ string seed[, boolean use_entropy ]])\r\n * \r\n * This ARC4 implementation is borrowed from http://davidbau.com/encode/seedrandom.js\r\n * with modifications for this module.\r\n */\n\n\nexports.arc4 = function (pool, math, width, chunks, significance, overflow, startdenom) {\n  // LICENSE (BSD):\n  //\n  // Copyright 2010 David Bau, all rights reserved.\n  //\n  // Redistribution and use in source and binary forms, with or without\n  // modification, are permitted provided that the following conditions are met:\n  // \n  //   1. Redistributions of source code must retain the above copyright\n  //      notice, this list of conditions and the following disclaimer.\n  //\n  //   2. Redistributions in binary form must reproduce the above copyright\n  //      notice, this list of conditions and the following disclaimer in the\n  //      documentation and/or other materials provided with the distribution.\n  // \n  //   3. Neither the name of this module nor the names of its contributors may\n  //      be used to endorse or promote products derived from this software\n  //      without specific prior written permission.\n  // \n  // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n  // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n  // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n  // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n  // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n  // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n  // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n  // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n  // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n  // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  var ret = function ret() {\n    return random();\n  };\n\n  var random = function random() {\n    throw 'You must seed the ARC4 generator before using it';\n  };\n\n  ret.seed = function seedrandom(seed, use_entropy) {\n    var key = [];\n    var arc4;\n    seed = mixkey(flatten(use_entropy ? [seed, pool] : arguments.length ? seed : [new Date().getTime(), pool, window], 3), key);\n    arc4 = new ARC4(key);\n    mixkey(arc4.S, pool);\n\n    random = function random() {\n      var n = arc4.g(chunks);\n      var d = startdenom;\n      var x = 0;\n\n      while (n < significance) {\n        n = (n + x) * width;\n        d *= width;\n        x = arc4.g(1);\n      }\n\n      while (n >= overflow) {\n        n /= 2;\n        d /= 2;\n        x >>>= 1;\n      }\n\n      return (n + x) / d;\n    };\n\n    return seed;\n  };\n\n  function ARC4(key) {\n    var t,\n        u,\n        me = this,\n        keylen = key.length;\n    var i = 0,\n        j = me.i = me.j = me.m = 0;\n    me.S = [];\n    me.c = [];\n\n    if (!keylen) {\n      key = [keylen++];\n    }\n\n    while (i < width) {\n      me.S[i] = i++;\n    }\n\n    for (i = 0; i < width; i++) {\n      t = me.S[i];\n      j = lowbits(j + t + key[i % keylen]);\n      u = me.S[j];\n      me.S[i] = u;\n      me.S[j] = t;\n    }\n\n    me.g = function getnext(count) {\n      var s = me.S;\n      var i = lowbits(me.i + 1);\n      var t = s[i];\n      var j = lowbits(me.j + t);\n      var u = s[j];\n      s[i] = u;\n      s[j] = t;\n      var r = s[lowbits(t + u)];\n\n      while (--count) {\n        i = lowbits(i + 1);\n        t = s[i];\n        j = lowbits(j + t);\n        u = s[j];\n        s[i] = u;\n        s[j] = t;\n        r = r * width + s[lowbits(t + u)];\n      }\n\n      me.i = i;\n      me.j = j;\n      return r;\n    };\n\n    me.g(width);\n  }\n\n  function flatten(obj, depth, result, prop, typ) {\n    result = [];\n    typ = typeof obj;\n\n    if (depth && typ == 'object') {\n      for (prop in obj) {\n        if (prop.indexOf('S') < 5) {\n          try {\n            result.push(flatten(obj[prop], depth - 1));\n          } catch (e) {}\n        }\n      }\n    }\n\n    return result.length ? result : obj + (typ != 'string' ? '\\0' : '');\n  }\n\n  function mixkey(seed, key, smear, j) {\n    seed += '';\n    smear = 0;\n\n    for (j = 0; j < seed.length; j++) {\n      key[lowbits(j)] = lowbits((smear ^= key[lowbits(j)] * 19) + seed.charCodeAt(j));\n    }\n\n    seed = '';\n\n    for (j in key) {\n      seed += String.fromCharCode(key[j]);\n    }\n\n    return seed;\n  }\n\n  function lowbits(n) {\n    return n & width - 1;\n  }\n\n  startdenom = math.pow(width, chunks);\n  significance = math.pow(2, significance);\n  overflow = significance * 2;\n  mixkey(math.random(), pool);\n  return ret; // End anonymous scope, and pass initial values.\n}([], // pool: entropy pool starts empty\nMath, // math: package containing random, pow, and seedrandom\n256, // width: each RC4 output is 0 <= x < 256\n6, // chunks: at least six RC4 outputs for each double\n52 // significance: there are 52 significant digits in a double\n);\n/* End of file rand.js */","map":null,"metadata":{},"sourceType":"script"}