{"ast":null,"code":"var _toConsumableArray = require(\"/home/josh/Desktop/Thinkful/projects/pcap/Client/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/home/josh/Desktop/Thinkful/projects/pcap/Client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/josh/Desktop/Thinkful/projects/pcap/Client/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('./card'),\n    Card = _require.Card;\n\nvar _require2 = require('./rand'),\n    shuffle = _require2.shuffle;\n/**\r\n * @private\r\n * @type {Map.<Deck, Object>}\r\n */\n\n\nvar props = new WeakMap();\n/**\r\n * @private\r\n * @type {Set.<string>}\r\n */\n\nvar piles = new Set(['deck', 'discard', 'held']);\n/**\r\n * @class Deck\r\n * @param cards {Card[]}\r\n */\n\nvar Deck =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function Deck() {\n    var _this = this;\n\n    var cards = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    _classCallCheck(this, Deck);\n\n    props.set(this, {\n      cards: new Set(cards),\n      deck: cards.slice(),\n      held: [],\n      discard: []\n    }); // Assign each card to the deck\n\n    cards.forEach(function (card) {\n      card.deck = _this;\n    });\n  }\n  /**\r\n   * @type {number}\r\n   * @description The total number of cards belonging to this deck\r\n   */\n\n\n  _createClass(Deck, [{\n    key: \"add\",\n\n    /**\r\n     * Add a new card to the deck, placing it in the given pile\r\n     *\r\n     * @param card {Card}\r\n     * @param pile {'deck'|'discard'|'held'}\r\n     * @return void\r\n     */\n    value: function add(card) {\n      var pile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'deck';\n\n      if (!piles.has(pile)) {\n        throw new Error(\"Deck: cannot add card to unknown pile \\\"\".concat(pile, \"\\\"\"));\n      }\n\n      var _props = props.get(this);\n\n      card.deck = this;\n\n      _props.cards.add(card);\n\n      _props[pile].push(card);\n    }\n    /**\r\n     * Removes a card from the deck entirely\r\n     *\r\n     * @param card {Card}\r\n     * @return void\r\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(card) {\n      var _props$get = props.get(this),\n          cards = _props$get.cards,\n          deck = _props$get.deck,\n          discard = _props$get.discard,\n          held = _props$get.held;\n\n      cards.delete(card);\n\n      _remove(deck, card);\n\n      _remove(discard, card);\n\n      _remove(held, card);\n\n      card.deck = null;\n    }\n    /**\r\n     * Draw the given number of cards, places them in the held pile, and returns the drawn cards\r\n     *\r\n     * @param count {number}\r\n     * @return {Card[]}\r\n     */\n\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      var _props$get2 = props.get(this),\n          deck = _props$get2.deck,\n          held = _props$get2.held;\n\n      if (!deck.length) {\n        throw new Error('Deck: Cannot draw from deck, no cards remaining');\n      }\n\n      if (count < 0) {\n        return [];\n      }\n\n      var cards = deck.splice(0, count);\n      held.push.apply(held, _toConsumableArray(cards));\n      return cards;\n    }\n    /**\r\n     * Draw the given number of cards from the bottom of the deck, places them in the held pile,\r\n     * and returns the drawn cards\r\n     *\r\n     * @param count {number}\r\n     * @return {Card[]}\r\n     */\n\n  }, {\n    key: \"drawFromBottom\",\n    value: function drawFromBottom() {\n      var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      var _props$get3 = props.get(this),\n          deck = _props$get3.deck,\n          held = _props$get3.held;\n\n      if (!deck.length) {\n        throw new Error('Deck: Cannot draw from deck, no cards remaining');\n      }\n\n      if (count < 0) {\n        return [];\n      }\n\n      var start = Math.max(deck.length - count, 0);\n      var cards = deck.splice(start, count).reverse();\n      held.push.apply(held, _toConsumableArray(cards));\n      return cards;\n    }\n    /**\r\n     * Draws the given number of cards, places them in the discard pile, and returns the drawn cards\r\n     *\r\n     * @param count {number}\r\n     * @return {Card[]}\r\n     */\n\n  }, {\n    key: \"drawToDiscard\",\n    value: function drawToDiscard() {\n      var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      var _props$get4 = props.get(this),\n          deck = _props$get4.deck,\n          discard = _props$get4.discard;\n\n      if (!deck.length) {\n        throw new Error('Deck: Cannot draw from deck, no cards remaining');\n      }\n\n      if (count < 0) {\n        return [];\n      }\n\n      var cards = deck.splice(0, count);\n      discard.push.apply(discard, _toConsumableArray(cards));\n      return cards;\n    }\n    /**\r\n     * Draw the given number of cards from the bottom of the deck, places them in the discard pile,\r\n     * and returns the drawn cards\r\n     *\r\n     * @param count {number}\r\n     * @return {Card[]}\r\n     */\n\n  }, {\n    key: \"drawToDiscardFromBottom\",\n    value: function drawToDiscardFromBottom() {\n      var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      var _props$get5 = props.get(this),\n          deck = _props$get5.deck,\n          discard = _props$get5.discard;\n\n      if (!deck.length) {\n        throw new Error('Deck: Cannot draw from deck, no cards remaining');\n      }\n\n      if (count < 0) {\n        return [];\n      }\n\n      var start = Math.max(deck.length - count, 0);\n      var cards = deck.splice(start, count).reverse();\n      discard.push.apply(discard, _toConsumableArray(cards));\n      return cards;\n    }\n    /**\r\n     * Moves the given card into the discard pile\r\n     *\r\n     * @param card {Card|Card[]}\r\n     * @return {void}\r\n     */\n\n  }, {\n    key: \"discard\",\n    value: function discard(card) {\n      var _this2 = this;\n\n      if (Array.isArray(card)) {\n        return card.forEach(function (card) {\n          return _this2.discard(card);\n        });\n      }\n\n      if (!(card instanceof Card)) {\n        throw new Error('Deck: Value provided is not a Card instance');\n      }\n\n      var _props$get6 = props.get(this),\n          cards = _props$get6.cards,\n          deck = _props$get6.deck,\n          held = _props$get6.held,\n          discard = _props$get6.discard;\n\n      if (!cards.has(card)) {\n        throw new Error('Deck: Provided card does not belong to this deck');\n      }\n\n      var deckIndex = deck.indexOf(card);\n\n      if (deckIndex >= 0) {\n        deck.splice(deckIndex, 1);\n        discard.push(card);\n      } else {\n        var heldIndex = held.indexOf(card);\n\n        if (heldIndex >= 0) {\n          held.splice(heldIndex, 1);\n          discard.push(card);\n        }\n      }\n    }\n    /**\r\n     * Finds the given card and returns an object representing its current location (pile, and index in that pile)\r\n     *\r\n     * @param card {Card}\r\n     * @return {{ pile: 'deck'|'discard'|'held', index: number, card: Card }}\r\n     */\n\n  }, {\n    key: \"locateCard\",\n    value: function locateCard(card) {\n      if (!(card instanceof Card)) {\n        throw new Error('Value provided is not a Card instance');\n      }\n\n      var _props$get7 = props.get(this),\n          cards = _props$get7.cards,\n          deck = _props$get7.deck,\n          held = _props$get7.held,\n          discard = _props$get7.discard;\n\n      if (!cards.has(card)) {\n        throw new Error('Provided card does not belong to this deck');\n      }\n\n      var deckIndex = deck.indexOf(card);\n\n      if (deckIndex >= 0) {\n        return {\n          pile: 'deck',\n          index: deckIndex,\n          card: card\n        };\n      }\n\n      var heldIndex = held.indexOf(card);\n\n      if (heldIndex >= 0) {\n        return {\n          pile: 'held',\n          index: heldIndex,\n          card: card\n        };\n      }\n\n      var discardIndex = discard.indexOf(card);\n\n      if (discardIndex >= 0) {\n        return {\n          pile: 'discard',\n          index: discardIndex,\n          card: card\n        };\n      } // This should never happen\n\n\n      throw new Error('Failed to find the given card');\n    }\n    /**\r\n     * Moves all cards back to the deck and shuffles the deck\r\n     *\r\n     * @return {void}\r\n     */\n\n  }, {\n    key: \"shuffleAll\",\n    value: function shuffleAll() {\n      var _props$get8 = props.get(this),\n          deck = _props$get8.deck,\n          held = _props$get8.held,\n          discard = _props$get8.discard;\n\n      deck.push.apply(deck, _toConsumableArray(held));\n      deck.push.apply(deck, _toConsumableArray(discard));\n      held.length = 0;\n      discard.length = 0;\n      shuffle(deck);\n    }\n    /**\r\n     * Shuffles the cards remaining in the deck\r\n     *\r\n     * @return {void}\r\n     */\n\n  }, {\n    key: \"shuffleRemaining\",\n    value: function shuffleRemaining() {\n      shuffle(props.get(this).deck);\n    }\n    /**\r\n     * Shuffles the cards in the discard pile and then places them at the end of the deck\r\n     *\r\n     * @return {void}\r\n     */\n\n  }, {\n    key: \"shuffleDiscard\",\n    value: function shuffleDiscard() {\n      var _props$get9 = props.get(this),\n          deck = _props$get9.deck,\n          discard = _props$get9.discard;\n\n      shuffle(discard);\n      deck.push.apply(deck, _toConsumableArray(discard));\n      discard.length = 0;\n    }\n    /**\r\n     * Moves all cards in the discard back to the deck and shuffles the deck\r\n     *\r\n     * @return {void}\r\n     */\n\n  }, {\n    key: \"shuffleDeckAndDiscard\",\n    value: function shuffleDeckAndDiscard() {\n      var _props$get10 = props.get(this),\n          deck = _props$get10.deck,\n          discard = _props$get10.discard;\n\n      deck.push.apply(deck, _toConsumableArray(discard));\n      discard.length = 0;\n      shuffle(deck);\n    }\n    /**\r\n     * Moves all currently held cards to the discard pile\r\n     *\r\n     * @return {void}\r\n     */\n\n  }, {\n    key: \"discardAllHeld\",\n    value: function discardAllHeld() {\n      var _props$get11 = props.get(this),\n          held = _props$get11.held,\n          discard = _props$get11.discard;\n\n      discard.push.apply(discard, _toConsumableArray(held));\n      held.length = 0;\n    }\n    /**\r\n     * Finds all cards in the deck matching the given filtering function\r\n     *\r\n     * ```javascript\r\n     * const aces = deck.findCards((card) => card.rank === ace);\r\n     * ```\r\n     *\r\n     * @param filter {function(Card):boolean}\r\n     * @return {Card[]}\r\n     */\n\n  }, {\n    key: \"findCards\",\n    value: function findCards(filter) {\n      var matching = [];\n      props.get(this).cards.forEach(function (card) {\n        if (filter(card)) {\n          matching.push(card);\n        }\n      });\n      return matching;\n    }\n  }, {\n    key: \"totalLength\",\n    get: function get() {\n      return props.get(this).cards.size;\n    }\n    /**\r\n     * @type {number}\r\n     * @description The current number of cards remaining in the deck pile\r\n     */\n\n  }, {\n    key: \"remainingLength\",\n    get: function get() {\n      return props.get(this).deck.length;\n    }\n  }]);\n\n  return Deck;\n}();\n\nexports.Deck = Deck;\n\nvar _remove = function _remove(array, value) {\n  var index = array.indexOf(value);\n\n  if (index >= 0) {\n    array.splice(index, 1);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}